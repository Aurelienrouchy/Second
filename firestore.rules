rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper functions for validation and authorization
    function isAuthenticated() {
      return request.auth != null;
    }
    
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }
    
    function isValidEmail(email) {
      return email is string && email.matches('.*@.*\\..*');
    }
    
    function isValidPrice(price) {
      return price is number && price >= 0.01 && price <= 10000;
    }
    
    function isValidString(str, minLen, maxLen) {
      return str is string && str.size() >= minLen && str.size() <= maxLen;
    }
    
    function isValidCondition(condition) {
      return condition in ['neuf', 'très bon état', 'bon état', 'satisfaisant'];
    }
    
    function isValidCoordinates(coords) {
      return coords.keys().hasAll(['lat', 'lon']) &&
             coords.lat is number && coords.lat >= -90 && coords.lat <= 90 &&
             coords.lon is number && coords.lon >= -180 && coords.lon <= 180;
    }
    
    // Shops Collection Rules
    match /shops/{shopId} {
      // Allow read for everyone (to find shops near them)
      allow read: if true;
      
      // Allow create for authenticated users
      allow create: if isAuthenticated() && 
                       request.auth.uid == request.resource.data.ownerId;
      
      // Allow update only by owner
      allow update: if isAuthenticated() && 
                       request.auth.uid == resource.data.ownerId;
      
      // No delete allowed
      allow delete: if false;
    }

    // Brands Collection Rules
    match /brands/{brandId} {
      allow read: if true;
      // Allow authenticated users to create custom brands
      allow create: if isAuthenticated() &&
                       request.resource.data.keys().hasAll(['label', 'value', 'searchKey']) &&
                       request.resource.data.isCustom == true;
      // Update and delete only via admin/script
      allow update, delete: if false;
    }

    // Notifications Collection Rules
    match /notifications/{notificationId} {
      allow read: if isAuthenticated() && resource.data.userId == request.auth.uid;
      allow update: if isAuthenticated() && resource.data.userId == request.auth.uid && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['read']);
      allow create: if false; // Only cloud functions can create notifications
    }

    // Articles Collection Rules (Alias for products, using same rules for now)
    match /articles/{articleId} {
      // Allow read for everyone for now to fix search issues
      allow read: if true;
      
      // Allow create for authenticated users with valid data
      allow create: if isAuthenticated() && 
                       request.auth.uid == request.resource.data.sellerId;
      
      // Allow update only by owner
      allow update: if isAuthenticated() && 
                       request.auth.uid == resource.data.sellerId;
      
      // Allow delete only by owner (soft delete by setting isActive = false)
      allow delete: if isAuthenticated() && 
                       request.auth.uid == resource.data.sellerId;
    }

    // Products Collection Rules
    match /products/{productId} {
      // Allow read for everyone for now to fix search issues
      allow read: if true;
      
      // Allow create for authenticated users with valid data
      allow create: if isAuthenticated() && 
                       request.auth.uid == request.resource.data.sellerId &&
                       isValidProductData(request.resource.data);
      
      // Allow update only by owner with valid data
      allow update: if isAuthenticated() && 
                       request.auth.uid == resource.data.sellerId &&
                       isValidProductUpdate(resource.data, request.resource.data);
      
      // Allow delete only by owner (soft delete by setting isActive = false)
      allow delete: if isAuthenticated() && 
                       request.auth.uid == resource.data.sellerId;
      
      function isValidProductData(data) {
        return data.keys().hasAll([
          'title', 'description', 'price', 'category', 'condition', 
          'sellerId', 'location', 'deliveryOptions', 'isActive', 'isSold'
        ]) &&
        // Title validation
        isValidString(data.title, 3, 100) &&
        // Description validation
        isValidString(data.description, 10, 2000) &&
        // Price validation
        isValidPrice(data.price) &&
        // Category validation
        isValidString(data.category, 1, 50) &&
        // Condition validation
        isValidCondition(data.condition) &&
        // Seller ID matches authenticated user
        data.sellerId == request.auth.uid &&
        // Location validation
        isValidLocation(data.location) &&
        // Delivery options validation
        isValidDeliveryOptions(data.deliveryOptions) &&
        // Status validation
        data.isActive is bool &&
        data.isSold is bool &&
        // Images validation (if present)
        (!('images' in data) || isValidImages(data.images)) &&
        // Metrics initialization
        data.views == 0 &&
        data.likes == 0 &&
        (!('likedBy' in data) || data.likedBy.size() == 0);
      }
      
      function isValidProductUpdate(oldData, newData) {
        return // Cannot change sellerId
               newData.sellerId == oldData.sellerId &&
               // Cannot directly modify metrics (handled by cloud functions)
               newData.views == oldData.views &&
               newData.likes == oldData.likes &&
               // Validate updated fields
               isValidString(newData.title, 3, 100) &&
               isValidString(newData.description, 10, 2000) &&
               isValidPrice(newData.price) &&
               isValidCondition(newData.condition) &&
               isValidLocation(newData.location) &&
               isValidDeliveryOptions(newData.deliveryOptions);
      }
      
      function isValidLocation(location) {
        return location.keys().hasAll(['city', 'postalCode', 'country', 'coordinates']) &&
               isValidString(location.city, 1, 100) &&
               isValidString(location.postalCode, 1, 20) &&
               isValidString(location.country, 2, 3) &&
               isValidCoordinates(location.coordinates);
      }
      
      function isValidDeliveryOptions(options) {
        return options.keys().hasAll(['pickup', 'shipping']) &&
               options.pickup is bool &&
               options.shipping is bool &&
               (options.pickup || options.shipping); // At least one must be true
      }
      
      function isValidImages(images) {
        return images is list &&
               images.size() >= 1 &&
               images.size() <= 10;
      }
    }
    
    // Users Collection Rules
    match /users/{userId} {
      // Allow read for any authenticated user (for seller profiles)
      allow read: if isAuthenticated();

      // Allow create only with valid initial data
      allow create: if isOwner(userId) && isValidUserData(request.resource.data);

      // Allow update by owner (more flexible for partial updates/preferences)
      allow update: if isOwner(userId);

      // No delete allowed (soft delete by setting isActive = false)
      allow delete: if false;

      function isValidUserData(data) {
        return data.keys().hasAll(['email', 'displayName']) &&
               isValidEmail(data.email) &&
               isValidString(data.displayName, 1, 50);
      }

      // Saved Searches Subcollection Rules
      match /savedSearches/{searchId} {
        // Allow read only by owner
        allow read: if isOwner(userId);

        // Allow create by owner
        allow create: if isOwner(userId);

        // Allow update by owner
        allow update: if isOwner(userId);

        // Allow delete by owner
        allow delete: if isOwner(userId);
      }

      // Search History Subcollection Rules
      match /searchHistory/{historyId} {
        // Allow read only by owner
        allow read: if isOwner(userId);

        // Allow create by owner
        allow create: if isOwner(userId);

        // Allow delete by owner
        allow delete: if isOwner(userId);
      }
    }
    
    // Favorites Collection Rules
    match /favorites/{userId} {
      // Allow read/write only by owner
      allow read, write: if isOwner(userId);
      
      // Validate favorites data structure
      allow write: if isValidFavoritesData(request.resource.data);
      
      function isValidFavoritesData(data) {
        return data.keys().hasAll(['userId', 'products', 'totalCount']) &&
               data.userId == request.auth.uid &&
               data.products is list &&
               data.totalCount is number &&
               data.totalCount == data.products.size();
      }
    }
    
    // Messages Collection Rules
    match /messages/{messageId} {
      // Allow read if user is a participant or it's a system message in their chat
      allow read: if isAuthenticated() &&
                     (request.auth.uid in resource.data.participants ||
                      resource.data.senderId == 'system');

      // Allow create if user is the sender with valid data OR it's a system message
      allow create: if isAuthenticated() &&
                       (isValidMessageCreate(request.resource.data) ||
                        isValidSystemMessage(request.resource.data));

      // Allow update for marking as read or updating offer status
      allow update: if isAuthenticated() &&
                       (request.auth.uid in resource.data.participants ||
                        resource.data.senderId == 'system');

      // No delete allowed
      allow delete: if false;

      function isValidMessageCreate(data) {
        return data.senderId == request.auth.uid &&
               data.senderId != data.receiverId &&
               data.type in ['text', 'image', 'offer'] &&
               data.chatId is string &&
               data.participants is list &&
               data.participants.size() == 2 &&
               request.auth.uid in data.participants;
      }

      function isValidSystemMessage(data) {
        return data.senderId == 'system' &&
               data.type == 'system' &&
               data.chatId is string;
      }
    }
    
    // Stats Collection Rules (Read-only for clients, write via Cloud Functions)
    match /stats/{statType} {
      // Allow read for authenticated users
      allow read: if isAuthenticated();
      
      // No direct writes allowed (managed by Cloud Functions)
      allow write: if false;
    }
    
    // Search Index Collection Rules (Read-only for clients)
    match /search_index/{productId} {
      // Allow read for searching
      allow read: if true;

      // No direct writes allowed (managed by Cloud Functions)
      allow write: if false;
    }

    // Embeddings Collection Rules (for AI-powered similarity search)
    match /embeddings/{articleId} {
      // Allow read for similarity search queries
      allow read: if true;

      // No direct writes allowed (managed by Cloud Functions)
      allow write: if false;
    }

    // Moments Collection Rules (for seasonal/event-based product discovery)
    match /moments/{momentId} {
      // Allow read for moment-based product sections
      allow read: if true;

      // No direct writes allowed (managed by scripts/Cloud Functions)
      allow write: if false;
    }

    // ============================================
    // SWAP SYSTEM RULES
    // ============================================

    // Swap Parties Collection Rules
    match /swapParties/{partyId} {
      // Anyone can read swap parties
      allow read: if true;

      // No create/delete - managed by Cloud Functions/scripts
      allow create, delete: if false;

      // Allow authenticated users to update counters only
      allow update: if isAuthenticated() &&
                       isValidPartyCounterUpdate(resource.data, request.resource.data);

      function isValidPartyCounterUpdate(oldData, newData) {
        // Only allow updating counter fields, nothing else
        return newData.diff(oldData).affectedKeys().hasOnly(['participantsCount', 'itemsCount', 'swapsCount', 'updatedAt']) &&
               newData.participantsCount is number &&
               newData.itemsCount is number &&
               newData.swapsCount is number;
      }
    }

    // Swap Party Participants Collection Rules
    match /swapPartyParticipants/{participantId} {
      // Anyone can read participants
      allow read: if true;

      // Users can join/leave parties (via Cloud Functions recommended)
      allow create: if isAuthenticated() &&
                       request.resource.data.userId == request.auth.uid;
      allow delete: if isAuthenticated() &&
                       resource.data.userId == request.auth.uid;
      allow update: if isAuthenticated() &&
                       resource.data.userId == request.auth.uid;
    }

    // Swap Party Items Collection Rules
    match /swapPartyItems/{itemId} {
      // Anyone can read items in a party
      allow read: if true;

      // Owners can add/remove their items
      allow create: if isAuthenticated() &&
                       request.resource.data.sellerId == request.auth.uid;
      allow delete: if isAuthenticated() &&
                       resource.data.sellerId == request.auth.uid;
      allow update: if isAuthenticated() &&
                       resource.data.sellerId == request.auth.uid;
    }

    // Swaps Collection Rules
    match /swaps/{swapId} {
      // Participants can read their swaps
      allow read: if isAuthenticated() &&
                     (resource.data.initiatorId == request.auth.uid ||
                      resource.data.receiverId == request.auth.uid);

      // Initiator can create a swap
      allow create: if isAuthenticated() &&
                       request.resource.data.initiatorId == request.auth.uid;

      // Participants can update their swap (accept, decline, add photos, etc.)
      allow update: if isAuthenticated() &&
                       (resource.data.initiatorId == request.auth.uid ||
                        resource.data.receiverId == request.auth.uid);

      // Only initiator can delete (cancel) a pending swap
      allow delete: if isAuthenticated() &&
                       resource.data.initiatorId == request.auth.uid &&
                       resource.data.status == 'proposed';
    }

    // Admin Collection Rules (Admin-only access)
    match /admin/{document=**} {
      // Only allow access for admin users
      allow read, write: if isAuthenticated() && 
                            request.auth.token.admin == true;
    }
    
    // Moderation Collection Rules
    match /moderation/{document=**} {
      // Allow read for moderators
      allow read: if isAuthenticated() && 
                     (request.auth.token.admin == true || 
                      request.auth.token.moderator == true);
      
      // Allow write for moderators
      allow write: if isAuthenticated() && 
                      (request.auth.token.admin == true || 
                       request.auth.token.moderator == true);
    }
    
    // Reports Collection Rules
    match /reports/{reportId} {
      // Allow create for authenticated users
      allow create: if isAuthenticated() && 
                       request.auth.uid == request.resource.data.reporterId &&
                       isValidReportData(request.resource.data);
      
      // Allow read for admins and moderators
      allow read: if isAuthenticated() && 
                     (request.auth.token.admin == true || 
                      request.auth.token.moderator == true);
      
      // Allow update for admins and moderators
      allow update: if isAuthenticated() && 
                       (request.auth.token.admin == true || 
                        request.auth.token.moderator == true);
      
      function isValidReportData(data) {
        return data.keys().hasAll(['reporterId', 'reportedItemId', 'reason', 'type']) &&
               data.reporterId == request.auth.uid &&
               isValidString(data.reason, 1, 500) &&
               data.type in ['product', 'user', 'message'];
      }
    }
    
    // Analytics Collection Rules (Read-only for admins)
    match /analytics/{document=**} {
      allow read: if isAuthenticated() && 
                     request.auth.token.admin == true;
      allow write: if false; // Managed by Cloud Functions
    }
    
    // Transactions Collection Rules
    match /transactions/{transactionId} {
      // Allow read if user is buyer or seller
      allow read: if isAuthenticated() &&
                     (request.auth.uid == resource.data.buyerId ||
                      request.auth.uid == resource.data.sellerId);

      // Allow create by buyer or seller with valid data
      allow create: if isAuthenticated() &&
                       (request.auth.uid == request.resource.data.buyerId ||
                        request.auth.uid == request.resource.data.sellerId) &&
                       isValidTransactionCreate(request.resource.data);

      // Allow update only by buyer or seller for specific fields
      allow update: if isAuthenticated() &&
                       (request.auth.uid == resource.data.buyerId ||
                        request.auth.uid == resource.data.sellerId) &&
                       isValidTransactionUpdate(resource.data, request.resource.data);

      // No delete allowed
      allow delete: if false;

      function isValidTransactionCreate(data) {
        return data.keys().hasAll(['articleId', 'buyerId', 'sellerId', 'amount', 'status']) &&
               data.articleId is string &&
               data.buyerId is string &&
               data.sellerId is string &&
               data.amount is number && data.amount > 0 &&
               data.status in ['pending', 'paid', 'shipped', 'delivered', 'completed', 'cancelled', 'refunded'];
      }

      function isValidTransactionUpdate(oldData, newData) {
        return // Cannot change core transaction data
               newData.articleId == oldData.articleId &&
               newData.buyerId == oldData.buyerId &&
               newData.sellerId == oldData.sellerId &&
               newData.amount == oldData.amount;
      }
    }
    
    // Seller Balances Collection Rules
    match /seller_balances/{userId} {
      // Allow read only by owner
      allow read: if isOwner(userId);
      
      // Allow create only by owner with valid initial data
      allow create: if isOwner(userId) && isValidBalanceData(request.resource.data);
      
      // Allow update only by owner or Cloud Functions
      allow update: if isOwner(userId) && isValidBalanceUpdate(resource.data, request.resource.data);
      
      // No delete allowed
      allow delete: if false;
      
      function isValidBalanceData(data) {
        return data.keys().hasAll(['userId', 'availableBalance', 'pendingBalance', 'totalEarnings', 'transactions']) &&
               data.userId == request.auth.uid &&
               data.availableBalance is number && data.availableBalance >= 0 &&
               data.pendingBalance is number && data.pendingBalance >= 0 &&
               data.totalEarnings is number && data.totalEarnings >= 0 &&
               data.transactions is list;
      }
      
      function isValidBalanceUpdate(oldData, newData) {
        return // User ID cannot change
               newData.userId == oldData.userId &&
               // Balances must be valid numbers
               newData.availableBalance is number && newData.availableBalance >= 0 &&
               newData.pendingBalance is number && newData.pendingBalance >= 0 &&
               newData.totalEarnings is number && newData.totalEarnings >= 0 &&
               // Transactions must be a list
               newData.transactions is list;
      }
    }
    
    // Chats Collection Rules
    match /chats/{chatId} {
      // Allow read if user is a participant
      allow read: if isAuthenticated() && 
                     request.auth.uid in resource.data.participants;
      
      // Allow create for authenticated users
      allow create: if isAuthenticated() && 
                       request.auth.uid in request.resource.data.participants &&
                       isValidChatData(request.resource.data);
      
      // Allow update only for unread count and last message
      allow update: if isAuthenticated() && 
                       request.auth.uid in resource.data.participants;
      
      // No delete allowed
      allow delete: if false;
      
      function isValidChatData(data) {
        return data.keys().hasAll(['participants', 'participantsInfo', 'unreadCount']) &&
               data.participants is list &&
               data.participants.size() == 2 &&
               request.auth.uid in data.participants &&
               data.participantsInfo is list &&
               data.unreadCount is map;
      }
    }
  }
}



